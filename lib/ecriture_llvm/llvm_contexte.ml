open Ast

type ctx = {
  mutable compteur: int;
  mutable compteur_chaine: int;
  mutable compteur_bloc: int;
  globales: Buffer.t;
  code: Buffer.t;
  mutable portee: (string * type_expression * string) list;
  mutable fonctions: (string * type_expression list * type_expression) list;
  mutable bloc_termine: bool;
}

let creer () = {
  compteur = 0;
  compteur_chaine = 0;
  compteur_bloc = 0;
  globales = Buffer.create 1024;
  code = Buffer.create 4096;
  portee = [];
  fonctions = [];
  bloc_termine = false;
}

let nom_frais ctx =
  ctx.compteur <- ctx.compteur + 1;
  Printf.sprintf "%%t%d" ctx.compteur

let label_frais ctx prefix =
  ctx.compteur_bloc <- ctx.compteur_bloc + 1;
  Printf.sprintf "%s%d" prefix ctx.compteur_bloc

let ecrire ctx fmt = Printf.bprintf ctx.code fmt

let globale ctx fmt = Printf.bprintf ctx.globales fmt

let echapper_chaine_llvm s =
  let buf = Buffer.create (String.length s * 2) in
  String.iter (fun c ->
    let code = Char.code c in
    if code >= 32 && code < 127 && c <> '"' && c <> '\\' then
      Buffer.add_char buf c
    else
      Printf.bprintf buf "\\%02X" code
  ) s;
  Buffer.contents buf

let enregistrer_chaine ctx s =
  ctx.compteur_chaine <- ctx.compteur_chaine + 1;
  let nom = Printf.sprintf "@.str.%d" ctx.compteur_chaine in
  let escaped = echapper_chaine_llvm s in
  let len = String.length s + 1 in
  Printf.bprintf ctx.globales "%s = private unnamed_addr constant [%d x i8] c\"%s\\00\"\n" nom len escaped;
  (nom, len)

let trouver_variable ctx nom =
  let rec aux = function
    | [] -> raise (Erreurs.variable_non_declaree nom)
    | (n, t, p) :: _ when n = nom -> (t, p)
    | _ :: q -> aux q
  in
  aux ctx.portee

let variable_existe ctx nom =
  List.exists (fun (n, _, _) -> n = nom) ctx.portee

let ajouter_variable ctx nom typ ptr =
  ctx.portee <- (nom, typ, ptr) :: ctx.portee

let sauvegarder_portee ctx = ctx.portee
let restaurer_portee ctx p = ctx.portee <- p

let enregistrer_fonction ctx nom types_params type_retour =
  ctx.fonctions <- (nom, types_params, type_retour) :: ctx.fonctions

let trouver_fonction ctx nom =
  let rec aux = function
    | [] -> raise (Erreurs.fonction_non_declaree nom)
    | (n, params, ret) :: _ when n = nom -> (params, ret)
    | _ :: q -> aux q
  in
  aux ctx.fonctions

let finaliser ctx canal =
  Printf.fprintf canal "; Generated by FranC\n\n";
  Printf.fprintf canal "declare i32 @printf(i8*, ...)\n";
  Printf.fprintf canal "declare double @sqrt(double)\n";
  Printf.fprintf canal "declare double @pow(double, double)\n";
  Printf.fprintf canal "declare double @fabs(double)\n";
  Printf.fprintf canal "declare i32 @abs(i32)\n";
  Printf.fprintf canal "declare i32 @rand()\n";
  Printf.fprintf canal "declare i32 @scanf(i8*, ...)\n";
  Printf.fprintf canal "declare void @srand(i32)\n";
  Printf.fprintf canal "declare i64 @time(i64*)\n";
  Printf.fprintf canal "declare i8* @malloc(i32)\n";
  Printf.fprintf canal "declare i8* @realloc(i8*, i32)\n";
  Printf.fprintf canal "declare void @free(i8*)\n";
  Printf.fprintf canal "declare void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)\n\n";
  Printf.fprintf canal "%%Tableau = type { i8*, i32, i32, i32 }\n\n";
  Printf.fprintf canal "@.fmt_d = private unnamed_addr constant [4 x i8] c\"%%d\\0A\\00\"\n";
  Printf.fprintf canal "@.fmt_f = private unnamed_addr constant [4 x i8] c\"%%f\\0A\\00\"\n\n";
  Buffer.output_buffer canal ctx.globales;
  Printf.fprintf canal "\n";
  Buffer.output_buffer canal ctx.code
